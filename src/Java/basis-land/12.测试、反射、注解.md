
# 测试、反射、注解

## 单元测试

### 单元测试概述

- 单元测试就是针对最小的功能单元编写测试代码，Java程序最小的功能单元是方法，因此，单元测试就是针对Java方法的测试，进而检查方法的正确性

#### Junit单元测试

- Junit是使用java语言实现的单元测试框架

#### Junit的优点

- Junit可以灵活的选择执行哪些测试方法，可以一键执行全部的测试方法

### 单元测试快速入门

1. 将Junit的jar包导入到项目中，一般IDEA通常整合好了Junit框架（在类中写@Test然后alt+回车自动导入）
2. 编写测试方法：**该测试方法必须是公共的无参的无返回值的非静态方法**
3. 在测试方法上加上@Test注解：标注该方法是一个测试方法
4. 编写测试的方法
5. 运行测试，如果测试良好则是绿色，反之失败红色

```java
package com.meng.d1_junit;

/**
 * 测试：Junit框架
 */
public class UserService {
    public String loginName(String loginName, String password) {
        if ("admin".equals(loginName) && "123456".equals(password)) return "登入成功";
        else return "用户名或密码错误";
    }

}

```

```java
package com.meng.d1_junit;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class TestUserService {
    @Test
    public void testLoginName() {
        UserService userService = new UserService();
        String rs = userService.loginName("admin", "123456");

        //预期结果的正确性：断言（有返回值的时候）
        Assertions.assertEquals(rs, "登入成功", "你的登入业务可能有bug");

    }
}

```

### 单元测试常用注解

| 注解         | 说明                                                               |
| ------------ | ------------------------------------------------------------------ |
| @Test        | 测试方法                                                           |
| @Before      | 用来修饰实例方法，该方法会在**每一个测试方法**执行前**都**执行一次 |
| @After       | 用来修饰实例方法，该方法会在**每一个测试方法**执行后**都**执行一次 |
| @BeforeClass | 用来静态修饰方法，该方法会在所有测试方法执行前**只**执行一次       |
| @AfterClass  | 用来静态修饰方法，该方法会在所有测试方法执行后**只**执行一次       |

- 开始执行的方法：**初始化**资源
- 执行完成后的方法：**释放资源**






## 注解

### 注解概述

- Java注解（Annotation）又称为java标注，是jdk5.0引入的一种注释机制
- java语言中的类、构造器、方法、成员变量、参数都可以被注解进行标记

![image-20220812160622854](https://raw.githubusercontent.com/redyouzi/images-for-blog/main/img02/202208121606958.png)



### 自定义注解

![image-20220812160719677](https://raw.githubusercontent.com/redyouzi/images-for-blog/main/img02/202208121607712.png)



- 自定义注解就是自己做一个注解来使用

```java
package com.meng.d8_annotation;

public @interface MyBook {
    String name();

    String[] authors();

    double price() default 50;//默认值50
}

```

- 特殊属性：value属性，如果只有一个value属性的话，使用value属性的时候可以省略不写
- 但是有多个属性的话，且多个属性没有默认值，那么value名称是不能省略的



### 元注解

- 就是注解的注解

#### 元注解有两个

- @Target：约束自定义注解只能在哪个地方使用
- @Retention：申明注解的生命周期

![image-20220812161701247](https://raw.githubusercontent.com/redyouzi/images-for-blog/main/img02/202208121617290.png)



```java
package com.meng.d8_annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.METHOD, ElementType.FIELD})//只可以在方法，成员变量上标注注解
@Retention(RetentionPolicy.RUNTIME)//永远都活着，在运行阶段被标记的注解也不会消失
public @interface MyTest {
}

```

![image-20220812162457896](https://raw.githubusercontent.com/redyouzi/images-for-blog/main/img02/202208121624981.png)

模拟Junit框架

```java
package day08.d3_annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyTest {
}

```

```java
package day08.d3_annotation;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class TestMyTest {
    @MyTest
    public void test1() {
        System.out.println("test1");
    }

    //    @MyTest
    public void test2() {
        System.out.println("test2");
    }

    @MyTest
    public void test3() {
        System.out.println("test3");
    }

    public static void main(String[] args) throws Exception {
        Class<TestMyTest> testMyTestClass = TestMyTest.class;
        Method[] declaredMethods = testMyTestClass.getDeclaredMethods();
        for (Method declaredMethod : declaredMethods) {
            if (declaredMethod.isAnnotationPresent(MyTest.class)) {
                declaredMethod.invoke(new TestMyTest());
            }
        }
    }

}

```

