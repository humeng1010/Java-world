---
title: 中小厂的面试过程 - 第一次面试

---

1. 首先自我介绍

2. 项目中遇到的最大的难题

3. 加密算法，对称加密

   > 对称加密只使用一把密钥来对数据进行加解密，而非对称加密使用两把密钥来进行加密，分别为公钥和私钥。
   >
   > 加密算法用于保护数据的机密性，其中对称加密算法是一种常见的加密技术。在对称加密中，同一个密钥用于加密和解密数据，因此发送方和接收方必须共享相同的密钥。常见的对称加密算法包括AES（高级加密标准）、DES（数据加密标准）和3DES（三重DES）等。
   >
   > ```java
   > import javax.crypto.Cipher;
   > import javax.crypto.KeyGenerator;
   > import javax.crypto.SecretKey;
   > import javax.crypto.spec.SecretKeySpec;
   > import java.util.Base64;
   > 
   > public class SymmetricEncryptionDemo {
   > 
   >     public static void main(String[] args) throws Exception {
   >         // 生成随机的对称密钥
   >         SecretKey secretKey = generateSymmetricKey();
   > 
   >         // 明文
   >         String plainText = "Hello, symmetric encryption!";
   > 
   >         // 加密
   >         String encryptedText = encrypt(plainText, secretKey);
   >         System.out.println("Encrypted Text: " + encryptedText);
   > 
   >         // 解密
   >         String decryptedText = decrypt(encryptedText, secretKey);
   >         System.out.println("Decrypted Text: " + decryptedText);
   >     }
   > 
   >     // 生成随机的对称密钥
   >     public static SecretKey generateSymmetricKey() throws Exception {
   >         KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
   >         keyGenerator.init(256); // 使用AES算法，设置密钥长度为256位
   >         return keyGenerator.generateKey();
   >     }
   > 
   >     // 使用对称密钥加密文本
   >     public static String encrypt(String plainText, SecretKey secretKey) throws Exception {
   >         Cipher cipher = Cipher.getInstance("AES");
   >         cipher.init(Cipher.ENCRYPT_MODE, secretKey);
   >         byte[] encryptedBytes = cipher.doFinal(plainText.getBytes());
   >         return Base64.getEncoder().encodeToString(encryptedBytes);
   >     }
   > 
   >     // 使用对称密钥解密文本
   >     public static String decrypt(String encryptedText, SecretKey secretKey) throws Exception {
   >         Cipher cipher = Cipher.getInstance("AES");
   >         cipher.init(Cipher.DECRYPT_MODE, secretKey);
   >         byte[] encryptedBytes = Base64.getDecoder().decode(encryptedText);
   >         byte[] decryptedBytes = cipher.doFinal(encryptedBytes);
   >         return new String(decryptedBytes);
   >     }
   > }
   > 
   > ```
   >
   > 

4. SpringCloudGateway网关的作用是什么，是否可以使用nginx代替

   > Spring Cloud Gateway是一个开源的微服务网关，主要用于构建和管理微服务架构中的路由、负载均衡、安全性、监控等功能。它的主要作用包括：
   >
   > 1. **路由管理：** Spring Cloud Gateway可以根据请求的路径和条件将请求路由到不同的微服务实例上，实现请求的动态路由。
   > 2. **负载均衡：** 它支持负载均衡策略，可以将请求均衡地分发给多个后端微服务，提高系统的可用性和性能。
   > 3. **安全性：** Spring Cloud Gateway可以与Spring Security等安全框架集成，提供身份验证、授权和安全策略的功能。
   > 4. **过滤器：** 可以通过自定义过滤器来进行请求和响应的处理，实现各种功能，如请求日志、鉴权、限流、缓存等。
   > 5. **监控和统计：** 提供了一些内置的监控和统计功能，帮助开发人员监控网关的性能和行为。
   >
   > 至于是否可以使用Nginx代替Spring Cloud Gateway，这取决于你的具体需求和架构。Nginx是一个高性能的反向代理服务器，它也可以用于路由、负载均衡和安全性，因此在某些情况下可以替代Spring Cloud Gateway。
   >
   > 下面是一些考虑因素：
   >
   > 1. **功能需求：** 如果你只需要基本的反向代理、负载均衡和静态文件服务，Nginx可能已经足够了。但如果你需要更复杂的路由、微服务支持、动态配置等功能，Spring Cloud Gateway可能更适合。
   > 2. **生态系统：** 如果你已经在使用Spring Cloud和Spring Boot构建微服务，那么使用Spring Cloud Gateway可以更好地集成到你的生态系统中。
   > 3. **技术栈：** 如果你的团队更熟悉Nginx，或者已经在使用Nginx，那么继续使用Nginx也是一个合理的选择。
   >
   > 总之，Spring Cloud Gateway和Nginx都有其适用的场景，你可以根据你的需求和团队的技术栈来选择合适的工具。有时候，它们甚至可以结合使用，例如将Nginx用作外部负载均衡器，而Spring Cloud Gateway用于微服务内部的路由和过滤。

5. 项目中的分布式锁是用来做什么的

   

6. 八大基本类型，char占用多少字节

   > byte short int long float double char boolean；char占用2个字节

7. String底层是使用什么保存字符串的，为什么后面把char数组修改了byte数组

   > - JDK 8及之前版本通常使用`char[]`来保存字符串的字符数据，每个字符占用两个字节。
   >
   > - JDK 9及之后版本引入了"Compact Strings"优化，根据字符串内容和字符集编码的不同，可以使用`char[]`或`byte[]`来保存字符串数据，以减少内存占用。

8. String类为什么需要使用final关键字修饰

   > `String`类在Java中被设计成`final`的，主要有以下几个原因：
   >
   > 1. **不可变性（Immutable）：** 使用`final`关键字修饰的类不能被继承，也不能被修改。因此，`String`类的不可变性得到了保障，即一旦创建了一个字符串对象，它的值就不能被修改。这对于字符串的安全性和稳定性非常重要。不可变性使得字符串可以被安全地共享、缓存和用作键值，而不必担心它们的值会在不经意间被修改。
   > 2. **安全性：** 因为字符串是不可变的，所以可以在多线程环境中安全地共享。多个线程可以同时访问相同的字符串对象，而不会出现并发修改的问题。这减少了需要使用额外同步机制的情况，提高了程序的性能和可维护性。
   > 3. **性能优化：** 由于字符串是不可变的，可以进行各种性能优化。例如，字符串可以被缓存，因为它们的值不会改变，这可以减少内存占用和提高性能。此外，字符串的哈希值可以在创建时计算，并在以后的访问中进行缓存，加快了哈希表等数据结构的性能。
   > 4. **设计简单：** 不可变性使得`String`类的设计更加简单明了。它不需要提供复杂的setter方法或考虑对象状态的改变，这降低了类的复杂度。

9. 创建线程的方式

   > 继承Thread类
   >
   > 实现Runnable接口
   >
   > 实现Callable接口
   >
   > 使用线程池创建

10. run方法和start方法的区别

    > `run`方法和`start`方法是与多线程编程相关的两个重要方法，它们之间有重要的区别：
    >
    > 1. **`run`方法：**
    >
    >    - `run`方法是线程对象的一个普通方法，用于定义线程的执行逻辑。
    >    - 当直接调用`run`方法时，它会在当前线程的上下文中执行，而不会创建一个新的线程。这意味着`run`方法的代码会在当前线程中按照普通的方法调用方式执行，不会实现多线程的并发执行。
    >    - 如果将多个线程的逻辑都定义在`run`方法中，并且直接调用`run`方法，那么这些线程将按顺序在同一个线程中执行，而不是并发执行。
    >
    >    示例：
    >
    >    ```java
    >    Thread myThread = new Thread(() -> {
    >        // 线程执行的逻辑
    >    });
    >    
    >    // 直接调用run方法，不会创建新线程，而是在当前线程中执行
    >    myThread.run();
    >    ```
    >
    > 2. **`start`方法：**
    >
    >    - `start`方法是用于启动一个新的线程的方法。
    >    - 当调用`start`方法时，会创建一个新的线程，然后在新线程中执行`run`方法中定义的逻辑。这样就实现了多线程的并发执行。
    >    - 一旦线程被启动，它的生命周期由Java虚拟机（JVM）管理，包括线程的调度、执行、挂起等状态。
    >
    >    示例：
    >
    >    ```java
    >    
    >    Thread myThread = new Thread(() -> {
    >        // 线程执行的逻辑
    >    });
    >    
    >    // 调用start方法，创建新线程并启动，执行run方法中的逻辑
    >    myThread.start();
    >    ```
    >
    > 总结：要实现多线程并发执行，应该使用`start`方法来启动线程。直接调用`run`方法只会在当前线程中执行，不会创建新的线程，因此不具备多线程的特性。

11. 反射可以修改final修饰的变量吗？比如`final int i = 1`，可以使用反射修改i吗？怎么获取到private修饰的变量？

    > 反射允许你访问和修改对象的字段，包括`private`字段，但它对`final`修饰的字段有一些限制。
    >
    > 1. **Final字段的修改：** 在Java中，`final`修饰的字段表示这个字段的值在初始化后不能被改变。尝试通过反射来修改`final`字段的值会导致`IllegalAccessException`异常。这是因为Java的`final`字段在**编译时会被编译器优化，使其成为常量，因此在运行时无法修改它们的值。**
    >
    >    示例代码：
    >
    >    ```java
    >    public class Main {
    >        public static void main(String[] args) throws Exception {
    >            Field field = MyClass.class.getDeclaredField("i");
    >            field.setAccessible(true);
    >            
    >            MyClass obj = new MyClass();
    >            System.out.println("原始值: " + obj.i);
    >            
    >            field.setInt(obj, 42); // 尝试修改final字段的值，会抛出异常
    >            System.out.println("修改后的值: " + obj.i);
    >        }
    >    }
    >    
    >    class MyClass {
    >        final int i = 1;
    >    }
    >    
    >    ```
    >
    > 2. **获取`private`字段：** 可以使用反射获取和修改`private`字段的值，但需要通过`setAccessible(true)`来解除字段的访问限制，否则会抛出`IllegalAccessException`异常。这是因为`private`字段默认是不可访问的。
    >
    >    示例代码：
    >
    >    ```java
    >    public class Main {
    >        public static void main(String[] args) throws Exception {
    >            Field field = MyClass.class.getDeclaredField("privateField");
    >            field.setAccessible(true);
    >            
    >            MyClass obj = new MyClass();
    >            System.out.println("原始值: " + field.getInt(obj));
    >            
    >            field.setInt(obj, 42); // 修改private字段的值
    >            System.out.println("修改后的值: " + field.getInt(obj));
    >        }
    >    }
    >    
    >    class MyClass {
    >        private int privateField = 1;
    >    }
    >    
    >    ```

    :::tip

    需要注意的是，反射具有很大的威力，但也需要谨慎使用。在使用反射时，应该遵循最小化访问原则，只在必要时才修改`private`字段，并确保在合适的上下文中进行。

    :::

12. 项目中是否有使用到多线程或者线程池？

    > 使用到了线程池去读取消息队列中的消息

13. CAS你是怎么理解的？比较并交换是怎么保证原子性的？

    > CAS（Compare-And-Swap）是一种用于实现多线程并发控制的原子操作。它通常用于解决多个线程同时修改共享数据时可能导致的竞态条件问题，从而确保线程安全性。CAS操作包括两个步骤：比较和交换。
    >
    > CAS操作的基本原理如下：
    >
    > 1. **比较（Compare）：** 首先，CAS操作会比较当前内存中的值与预期的值是否相等。
    > 2. **交换（Swap）：** 如果相等，CAS操作会将新值写入到内存中。否则，它会放弃操作，不做任何修改。
    >
    > CAS操作的关键是在比较和交换这两个步骤之间，不允许其他线程干扰。这确保了CAS操作是原子的，即在同一时刻只有一个线程可以成功执行CAS。如果多个线程同时尝试执行CAS，只有一个线程会成功，而其他线程会失败，需要重试。
    >
    > CAS操作通常用于实现各种并发数据结构和算法，如无锁队列、原子计数器、自旋锁等。它是一种无锁（lock-free）的同步机制，因为它不涉及线程阻塞和操作系统级别的锁。
    >
    > CAS操作的优点包括：
    >
    > - **无锁：** CAS避免了传统锁所带来的性能开销和线程阻塞。
    > - **原子性：** CAS操作是原子的，不会出现竞态条件。
    > - **可用于多线程环境：** CAS操作可以在多线程环境下使用，确保线程安全。
    >
    > 然而，CAS操作也有一些缺点：
    >
    > - **ABA问题：** CAS只关注值是否相等，不关注值的修改历史。因此，它可能忽略了在两次比较之间发生的其他操作，导致ABA问题。
    > - **循环开销：** 如果多个线程不断尝试CAS操作，但一直失败，会导致循环开销，消耗CPU资源。
    > - **不适用于所有场景：** CAS适用于一些特定的并发问题，但不是所有问题都可以使用CAS来解决。
    >
    > 为了解决CAS中的ABA问题，一些变种的CAS操作，如Double-Check Locking、ABA防范算法等，引入了版本号或标记来更准确地判断数据是否被修改。这些变种操作在具体应用中使用较多。
    >
    > 原子性是如何保证的？
    >
    > 比较并交换（CAS）是通过硬件的原子性操作指令来实现的，通常是借助CPU提供的一些特殊指令（如`compare-and-swap`或`compare-and-set`）来执行的。CAS操作确保原子性的方式如下：
    >
    > 1. **比较：** 在CAS操作中，首先会读取内存中的值，然后将其与预期的值进行比较。
    > 2. **交换：** 如果比较操作成功（即内存中的值等于预期的值），则CAS操作会尝试将新值写入到内存中。如果比较操作失败（内存中的值不等于预期的值），则CAS操作不会执行交换操作，而是返回失败。
    >
    > CAS操作的关键在于，它是在单个原子性操作中完成比较和交换的，不允许其他线程在这两个操作之间插入。这保证了CAS操作的原子性。
    >
    > 假设有多个线程同时尝试执行CAS操作，情况如下：
    >
    > 1. 线程A和线程B同时读取内存中的值，得到相同的值。
    > 2. 线程A首先尝试执行CAS操作，它会将新值写入内存，但只有在写入之前，内存中的值仍然与预期值相等时才会成功。
    > 3. 线程B尝试执行CAS操作，但由于内存中的值已经被线程A修改，所以比较操作失败，CAS操作返回失败，不执行交换操作。
    >
    > 这个过程保证了只有一个线程能够成功执行CAS操作，其他线程会失败并需要重试。
    >
    > 虽然CAS操作是原子的，但并不能阻止其他线程在比较和交换之间插入，但它能够保证只有一个线程最终成功执行交换操作，其他线程会失败。这种特性使得CAS操作在实现无锁数据结构和并发算法时非常有用，因为它可以避免线程之间的阻塞和竞争。但需要注意，由于CAS操作的不确定性，需要编写适当的重试逻辑来处理失败的情况。

    

14. MySQL有哪些日志

    > MySQL数据库中有多种类型的日志，这些日志记录了数据库的各种活动和事务信息，以便于故障恢复、性能调优和审计等目的。以下是MySQL中常见的日志类型：
    >
    > 1. **错误日志（Error Log）：** 错误日志记录了MySQL服务器在运行过程中遇到的错误、警告和异常情况。通常在MySQL的配置文件中指定错误日志文件的位置。错误日志对于故障诊断和排查非常重要。
    > 2. **查询日志（Query Log）：** 查询日志记录了MySQL服务器接收到的所有查询语句，包括SELECT、INSERT、UPDATE、DELETE等操作。查询日志可以用于审计和性能调优。在一些MySQL版本中，查询日志也被称为慢查询日志（Slow Query Log），用于记录执行时间较长的查询。
    > 3. **二进制日志（Binary Log）：** 二进制日志记录了数据库的更改操作，包括INSERT、UPDATE、DELETE等。它以二进制的方式记录数据的变化，主要用于数据复制、主从复制和恢复操作。二进制日志文件包括二进制日志文件和二进制日志索引文件。
    > 4. **重做日志（Redo Log）：** 重做日志记录了数据库引擎在执行事务期间所做的更改，以便在系统崩溃或故障时进行恢复。每个InnoDB存储引擎的表都有自己的重做日志。
    > 5. **错误重做日志（Error Redo Log）：** 错误重做日志（或错误日志重做日志）记录了InnoDB存储引擎在发生错误时所做的操作，以便在错误修复时进行恢复。
    > 6. **撤销日志（Undo Log）：** 撤销日志用于记录事务中的操作，以便在事务回滚时撤销更改。撤销日志对于保持数据的一致性非常重要。
    > 7. **日志文件（Log Files）：** 日志文件包括错误日志、二进制日志、查询日志等不同类型的日志文件，这些文件用于存储相应类型的日志信息。
    >
    > 这些日志在MySQL中发挥着不同的作用，帮助管理员和开发人员监视、维护和恢复数据库的正常运行。在生产环境中，定期备份这些日志是维护数据库完整性和安全性的重要一部分。

15. binlog和redolog的区别

    > `binlog`（二进制日志）和`redo log`（重做日志）是MySQL数据库中的两种不同类型的日志，它们具有不同的作用和特点。下面是它们之间的主要区别：
    >
    > 1. **作用和用途：**
    >    - `binlog`：`binlog`是用于数据复制和恢复的日志。它记录了数据库中所有更改数据的SQL语句，包括INSERT、UPDATE、DELETE等操作，以二进制格式记录。`binlog`用于主从复制、数据备份、点播恢复等任务。
    >    - `redo log`：`redo log`是用于事务的持久性和恢复的日志。它记录了InnoDB存储引擎在事务提交之前对数据所做的修改，以便在系统崩溃或故障时重新应用这些修改，确保数据的一致性和持久性。
    > 2. **日志格式：**
    >    - `binlog`：`binlog`以文本或二进制格式记录SQL语句，可以通过工具解析和读取。
    >    - `redo log`：`redo log`以二进制格式记录物理修改，不包含SQL语句，只包含修改前后的数据信息。
    > 3. **存储位置：**
    >    - `binlog`：`binlog`通常存储在指定的二进制日志文件中，这些文件可以配置的大小和数量。
    >    - `redo log`：`redo log`存储在InnoDB存储引擎的共享表空间中的多个物理日志文件中，包括`ib_logfile0`、`ib_logfile1`等。
    > 4. **日志记录时机：**
    >    - `binlog`：`binlog`记录在事务提交时生成，包括事务的SQL语句。
    >    - `redo log`：`redo log`记录在事务进行中，事务的修改会首先写入`redo log`，然后在事务提交时写入`binlog`。
    > 5. **恢复方式：**
    >    - `binlog`：`binlog`用于数据恢复和复制，通常在数据库崩溃后，可以使用`binlog`重新执行SQL语句以还原数据。
    >    - `redo log`：`redo log`用于事务的持久性和恢复。在系统崩溃或故障时，数据库引擎会使用`redo log`重新应用事务的修改，以确保数据的一致性。
    >
    > 总结：`binlog`和`redo log`是MySQL中两种不同的日志，分别用于数据复制和恢复以及事务的持久性和恢复。它们在格式、作用、存储位置和恢复方式等方面有明显的区别，但在数据库的正常运行和数据保持一致性方面都起着重要作用。

16. MySQL索引失效的情况

    > MySQL索引是用于加速数据库查询的关键组件，但在某些情况下，索引可能会失效，导致查询性能下降。以下是一些导致MySQL索引失效的常见情况：
    >
    > 1. **不使用索引字段：** 当查询中不使用索引中的字段时，索引会失效。例如，如果一个表有一个索引列A，但查询中只包含列B，那么索引A就不会被使用，导致性能下降。
    >
    >    ```sql
    >    -- 索引失效的例子
    >    SELECT * FROM mytable WHERE columnB = 'value';
    >    ```
    >
    > 2. **索引列进行了函数操作：** 如果在查询中对索引列进行了函数操作，如`UPPER`、`LOWER`、`CONCAT`等，索引可能无法被有效使用，因为索引列的值已经被改变。
    >
    >    ```sql
    >    -- 索引失效的例子
    >    SELECT * FROM mytable WHERE UPPER(columnA) = 'VALUE';
    >    ```
    >
    > 3. **使用通配符前缀：%：** 当使用`LIKE`操作符以通配符`%`作为前缀时，索引通常无法被利用，因为它难以进行前缀匹配。
    >
    >    ```sql
    >    -- 索引失效的例子
    >    SELECT * FROM mytable WHERE columnC LIKE '%value';
    >    ```
    >
    > 4. **列类型不匹配：** 如果查询中的列类型与索引列的类型不匹配，索引可能无法使用。
    >
    >    ```sql
    >    -- 索引失效的例子
    >    SELECT * FROM mytable WHERE columnD = 123;  -- 如果columnD是字符串类型的索引
    >    ```
    >
    > 5. **不满足索引的最左前缀原则：** MySQL使用最左前缀匹配索引。如果查询条件不满足索引的最左前缀，那么索引会失效。
    >
    >    ```sql
    >    -- 索引失效的例子（如果索引是 (col1, col2)）
    >    SELECT * FROM mytable WHERE col2 = 'value';
    >    ```
    >
    > 6. **表中数据分布不均匀：** 如果表中数据分布不均匀，索引可能会失效，因为MySQL可能选择不使用索引来扫描更大的数据块。
    >
    > 7. **小表扫描：** 对于非常小的表，MySQL可能会选择全表扫描而不是使用索引，因为索引的开销可能大于全表扫描的开销。
    >
    > 8. **使用OR条件：** 当查询中使用多个OR条件时，索引可能会失效。这时可能需要考虑重写查询以使用UNION或其他方式来避免OR条件。
    >
    >    ```sql
    >    -- 索引失效的例子
    >    SELECT * FROM mytable WHERE columnE = 'value1' OR columnF = 'value2';
    >    ```
    >
    > 为了避免索引失效，开发人员需要仔细设计查询，确保查询条件和索引的使用方式是有效的。可以使用`EXPLAIN`语句来分析查询计划，以确定是否使用了索引。此外，了解MySQL索引的工作原理和最佳实践也有助于避免索引失效问题。

17. 模糊查询的`%`在左边为什么会失效

    > 在模糊查询中，`%`通配符在左边使用会导致索引失效的原因是与索引的工作原理有关。MySQL的B-tree索引（包括B+树索引）通常只能有效利用前缀匹配。当通配符`%`位于左边时，索引的前缀匹配特性就无法发挥作用，从而导致索引失效。
    >
    > 以下是一个示例来解释为什么通配符`%`在左边会导致索引失效：
    >
    > 假设有一个名为`name`的列，我们希望查找名字以"John"开头的记录：
    >
    > ```sql
    > SELECT * FROM employees WHERE name LIKE 'John%';
    > ```
    >
    > 如果`name`列上有一个索引，该索引只能有效地支持前缀匹配。对于这个查询，MySQL会扫描索引，但由于`%`通配符在左边，MySQL无法确定"John"之前有多少字符，因此无法有效地使用索引来定位匹配的记录。它不得不执行全表扫描来查找所有以"John"开头的记录。
    >
    > 为了优化这种情况，可以考虑将通配符放在右边，这样索引可以用于前缀匹配，如下所示：
    >
    > ```sql
    > SELECT * FROM employees WHERE name LIKE 'John%';
    > ```
    >
    > 这样查询将能够利用索引来快速定位以"John"开头的记录。
    >
    > 如果需要支持通配符在左边的模糊查询，并且要使用索引，可以考虑使用全文搜索引擎（如MySQL的全文搜索功能）或者其他专门用于支持左侧通配符的索引技术。然而，这些方法可能会涉及到不同的索引结构和查询语法。

18. 数据库表中保存了手机号，现在需要通过手机号后四位来索引，那我们需要怎么来创建索引呢？

    > 如果你希望通过手机号的后四位来索引数据库表，可以考虑创建一个用于存储手机号后四位的列，并在该列上创建索引。以下是创建索引的一般步骤：
    >
    > 1. **创建一个新列来存储手机号后四位：** 在数据库表中添加一个新的列，例如命名为`last_four_digits`，用于存储手机号的后四位。
    >
    >    ```sql
    >    ALTER TABLE your_table ADD COLUMN last_four_digits VARCHAR(4);
    >    ```
    >
    > 2. **将手机号数据填充到新列中：** 使用UPDATE语句将现有的手机号数据的后四位复制到新列中。
    >
    >    ```sql
    >    UPDATE your_table SET last_four_digits = RIGHT(phone_number, 4);
    >    ```
    >
    >    这里假设`phone_number`是存储手机号的列名。
    >
    > 3. **创建索引：** 在新列`last_four_digits`上创建索引。
    >
    >    ```sql
    >    CREATE INDEX idx_last_four_digits ON your_table(last_four_digits);
    >    ```
    >
    > 现在，你已经在存储手机号后四位的列上创建了一个索引，可以使用这个索引来加速查询，例如通过后四位来查找具体的手机号记录：
    >
    > ```sql
    > SELECT * FROM your_table WHERE last_four_digits = '1234';
    > ```
    >
    > 这种方式使得你可以更快地进行后四位的匹配查询，而无需对整个手机号进行字符串匹配，从而提高了查询性能。请确保在数据更新时保持`last_four_digits`列的一致性，以确保索引的正确性。

19. Redis的数据类型以及数据类型底层对应的数据结构

    > Redis是一种内存数据库，支持多种数据类型，每种数据类型都对应着不同的底层数据结构，这些数据类型包括：
    >
    > 1. **字符串（String）：**
    >    - 底层数据结构：简单动态字符串（SDS，Simple Dynamic String）。
    >    - 示例操作：`SET key value`, `GET key`, `INCR key`, `APPEND key value`等。
    > 2. **列表（List）：**
    >    - 底层数据结构：双向链表。
    >    - 示例操作：`LPUSH key value`, `RPUSH key value`, `LPOP key`, `RPOP key`等。
    > 3. **集合（Set）：**
    >    - 底层数据结构：哈希表（Hash Table）或者整数数组（Intset，仅存储整数的集合）。
    >    - 示例操作：`SADD key member`, `SREM key member`, `SMEMBERS key`等。
    > 4. **有序集合（Sorted Set）：**
    >    - 底层数据结构：跳跃表（Skip List）+哈希表。
    >    - 示例操作：`ZADD key score member`, `ZREM key member`, `ZRANGE key start stop`等。
    > 5. **哈希（Hash）：**
    >    - 底层数据结构：哈希表（Hash Table）。
    >    - 示例操作：`HSET key field value`, `HGET key field`, `HDEL key field`等。
    > 6. **位图（Bitmap）：**
    >    - 底层数据结构：使用字符串实现的位数组。
    >    - 示例操作：`SETBIT key offset value`, `GETBIT key offset`, `BITCOUNT key`等。
    > 7. **HyperLogLog：**
    >    - 底层数据结构：基于哈希的数据结构，用于估计基数（不重复元素的数量）。
    >    - 示例操作：`PFADD key element`, `PFCOUNT key`等。
    > 8. **地理位置（Geospatial）：**
    >    - 底层数据结构：使用ZSET和Geohash的组合结构。
    >    - 示例操作：`GEOADD key longitude latitude member`, `GEORADIUS key longitude latitude radius`等。
    >
    > 每种数据类型都有其特定的用途和适用场景，根据需求选择合适的数据类型可以高效地解决各种问题。Redis的底层数据结构经过优化，使其在性能和空间利用上都有较好的表现。

20. Redis是线程安全的吗？为什么？你是怎么理解Redis的单线程模型的？它是只有一个线程工作吗？

    > Redis是线程安全的，但它采用了单线程模型的方式来处理请求。这可能会让人感到矛盾，因此需要解释一下Redis的线程模型。
    >
    > 1. **单线程模型：** Redis的单线程模型指的是在主要的工作线程中只有一个线程来处理客户端请求和执行命令。这个单线程负责接收客户端请求、解析命令、执行命令以及将结果返回给客户端。这个单线程是Redis的核心处理引擎。
    > 2. **非阻塞I/O：** Redis的单线程并不意味着它不能充分利用多核CPU。它采用了非阻塞I/O和事件驱动的机制，通过使用I/O多路复用来处理多个客户端连接。这使得Redis能够同时处理多个客户端请求，而不会因为阻塞而浪费CPU资源。
    > 3. **线程安全：** Redis的单线程模型对于多个客户端请求是线程安全的。这是因为Redis内部采用了一些技术来确保并发的安全性，例如在执行命令时使用了事务和锁机制。
    > 4. **命令的顺序执行：** 单线程模型意味着Redis会顺序执行客户端的命令请求，不会并行处理不同命令。这有助于避免复杂的并发控制问题，但也可能导致某些命令执行较慢。
    >
    > Redis之所以采用单线程模型的主要原因是为了避免多线程带来的复杂性和竞态条件，以简化数据一致性的管理。此外，单线程模型能够更好地利用CPU缓存，提高了处理速度。
    >
    > 尽管Redis的主要工作线程是单线程，但它在内部仍然使用了一些并发控制机制，以确保数据的一致性和线程安全性。因此，虽然Redis采用了单线程模型，但它仍然能够高效地处理并发请求。如果需要更高的并发性能，可以通过多个Redis实例构建Redis集群来实现。每个实例都是单线程的，但多个实例可以并行处理请求，从而提高了整体性能。

21. Redis它是单线程的为什么访问速度这么快？

    > Redis之所以能够以极快的速度访问数据，尽管它采用了单线程模型，是因为Redis具备以下一些关键特性和优化：
    >
    > 1. **内存存储：** Redis主要是一个基于内存的数据库，数据存储在内存中，因此可以实现非常快速的数据读取和写入。内存速度远高于磁盘访问速度。
    > 2. **高效的数据结构：** Redis提供了多种高效的数据结构，如哈希表、有序集合、位图等，这些数据结构经过优化，可以在单个命令下执行复杂的操作，而不需要多次往返到数据库。
    > 3. **非阻塞I/O：** Redis采用了非阻塞I/O和事件驱动的模型，通过使用I/O多路复用技术，单线程可以同时处理多个客户端请求，而不会阻塞在等待I/O操作上。
    > 4. **单线程优势：** 单线程模型可以避免多线程并发控制所带来的开销和竞态条件，简化了数据一致性的管理。此外，单线程模型能够更好地利用CPU缓存，减少了上下文切换的开销。
    > 5. **快速持久性选项：** Redis支持多种快速持久性选项，如快照（snapshotting）和追加文件（append-only file），这些选项可以在需要时将数据持久化到磁盘，但不会对读取性能产生太大的影响。
    > 6. **网络优化：** Redis采用高性能的网络库，能够快速处理客户端请求和响应。此外，Redis支持多个网络连接，可以同时处理多个客户端请求。
    > 7. **复杂命令的优化：** Redis对一些复杂命令进行了优化，例如，在某些情况下，它可以通过单个命令来实现多个操作，而不需要多次通信。
    >
    > 总之，Redis之所以在单线程模型下能够实现如此高的访问速度，是因为它充分利用了内存、采用了高效的数据结构、优化了网络通信和I/O操作、避免了多线程带来的复杂性，并提供了多种性能优化选项。这使得Redis成为了一个非常适合高性能数据存储和缓存的解决方案。当然，在不同的使用场景下，Redis的性能也受到硬件配置、数据量和访问模式等因素的影响。

22. Redis持久化的时候还是用这一个线程进行持久化吗？那在持久化的时候怎么去处理其他的请求呢？

    > 在Redis中，持久化操作和处理其他客户端请求是由同一个主线程处理的。Redis的持久化操作通常包括两种方式：RDB快照（Snapshotting）和AOF日志（Append-Only File），它们都是在主线程中执行的。持久化操作不会阻塞其他客户端请求的处理，这是通过异步执行持久化操作来实现的。
    >
    > 具体来说，Redis的持久化操作如下：
    >
    > 1. **RDB快照：** 在执行RDB快照持久化时，Redis主线程会将内存中的数据保存到磁盘上的RDB文件中。这个过程通常会比较耗时，但Redis的处理方式是异步的。主线程会创建一个子进程来执行RDB快照操作，而主线程本身不会阻塞，可以继续处理其他客户端请求。当RDB快照操作完成后，Redis会用新的数据文件替换旧的RDB文件，以实现数据的持久化。
    > 2. **AOF日志：** AOF日志是通过将命令追加到AOF文件的方式来实现持久化。Redis主线程会将每个写操作的命令追加到AOF文件中，以记录数据的修改。这个过程也是异步执行的，主线程不会阻塞，可以继续响应其他请求。Redis还可以配置AOF文件的刷写策略，以控制刷写到磁盘的频率。例如，可以设置在每秒钟执行一次刷写操作。
    >
    > 总之，Redis的持久化操作是通过异步方式执行的，主线程不会阻塞，可以继续处理其他客户端请求。这一特性使得Redis能够在高并发的情况下保持较低的响应延迟，并且保持了数据的一致性。但需要注意的是，如果在执行RDB快照或AOF重写等持久化操作时，磁盘I/O负载较重，可能会影响到其他请求的响应速度，因此在生产环境中需要根据实际需求进行性能调优和硬件配置。

23. 说一下你熟悉的SpringCloud原生的组件

    > Spring Cloud是一个用于构建分布式系统和微服务架构的开发工具集合，它包含许多原生组件，用于解决微服务架构中的各种问题。以下是一些常见的Spring Cloud原生组件：
    >
    > 1. **Eureka（服务注册与发现）：** Eureka是一个用于实现服务注册和发现的组件，它允许微服务应用注册自己并发现其他微服务的位置。Eureka有两个组件：Eureka Server和Eureka Client。
    > 2. **Ribbon（客户端负载均衡）：** Ribbon是一个客户端负载均衡器，它可以集成到微服务应用中，用于在多个服务实例之间均衡分发请求。
    > 3. **Feign（声明式HTTP客户端）：** Feign是一个声明式的HTTP客户端，它简化了微服务之间的通信，开发人员可以使用注解来定义HTTP请求和响应。
    > 4. **Hystrix（容错和熔断器）：** Hystrix是一个容错和熔断器库，用于处理微服务之间的故障和延迟。它可以防止故障扩散，并提供降级机制。
    > 5. **Zuul（API网关）：** Zuul是一个API网关，用于管理和路由微服务之间的请求。它可以处理路由、负载均衡、认证、授权等任务。
    > 6. **Config（分布式配置管理）：** Config组件允许将应用程序的配置集中管理，并支持配置的动态刷新。它可以与Git等版本控制系统集成。
    > 7. **Bus（消息总线）：** Bus组件允许微服务之间通过消息传递机制来通信，用于实现配置的动态刷新和事件广播。
    > 8. **Sleuth（分布式跟踪）：** Sleuth是一个用于分布式跟踪的工具，可以帮助开发人员监视和分析微服务应用程序的请求链路。
    > 9. **Stream（消息驱动微服务）：** Stream组件提供了一种简化消息驱动微服务的方式，它基于Spring Cloud Stream构建，支持多种消息中间件。
    > 10. **Security（安全性）：** Spring Cloud Security用于实现微服务应用程序的安全性，包括认证、授权和身份验证。
    >
    > 这些是Spring Cloud中的一些核心原生组件，它们提供了一系列工具和功能，有助于构建和管理分布式系统和微服务架构。根据项目的需求，开发人员可以选择合适的组件来构建自己的微服务应用。此外，Spring Cloud还不断演进和增加新的组件，以满足不断变化的微服务开发需求。
    >
    > 补充：
    >
    > OpenFeign是一个用于简化HTTP客户端开发的声明式Web服务客户端框架，它是Spring Cloud生态系统的一部分，旨在简化微服务架构中的服务间通信。通过OpenFeign，开发人员可以使用Java接口来定义HTTP请求，而无需编写具体的HTTP客户端代码。以下是OpenFeign的主要特点和用法：
    >
    > **主要特点：**
    >
    > 1. **声明式API定义：** 使用OpenFeign，你可以创建一个Java接口，通过注解来定义HTTP请求，包括请求方法、路径、参数、请求头等。这使得接口定义更加直观和可读。
    > 2. **自动化编码：** OpenFeign会自动根据接口定义生成HTTP请求的实现代码，开发人员无需手动编写HTTP请求的发送代码。
    > 3. **集成负载均衡：** OpenFeign可以集成Ribbon，从而实现客户端负载均衡，可以轻松分发请求到多个服务实例。
    > 4. **集成熔断器：** OpenFeign可以与Hystrix集成，提供容错和熔断机制，防止故障扩散。
    > 5. **多种编码器：** OpenFeign支持多种编码器，可以处理不同类型的数据，如JSON、XML等。
    >
    > **使用方法：**
    >
    > 1. **引入依赖：** 在项目的`pom.xml`文件中引入OpenFeign依赖：
    >
    >    ```xml
    >    <dependency>
    >        <groupId>org.springframework.cloud</groupId>
    >        <artifactId>spring-cloud-starter-openfeign</artifactId>
    >    </dependency>
    >    ```
    >
    > 2. **创建Feign接口：** 创建一个Java接口，使用`@FeignClient`注解来标记要调用的服务名以及配置属性。
    >
    >    ```java
    >    @FeignClient(name = "example-service")
    >    public interface ExampleFeignClient {
    >        
    >        @GetMapping("/example")
    >        String getExample();
    >    }
    >    ```
    >
    > 3. **使用Feign接口：** 在你的代码中，通过注入Feign接口的实例来调用远程服务。
    >
    >    ```java
    >    @RestController
    >    public class MyController {
    >        
    >        @Autowired
    >        private ExampleFeignClient exampleFeignClient;
    >        
    >        @GetMapping("/callExampleService")
    >        public String callExampleService() {
    >            return exampleFeignClient.getExample();
    >        }
    >    }
    >    ```
    >
    > 4. **配置属性：** 你可以通过配置文件或属性来配置Feign客户端的行为，例如配置负载均衡策略、超时时间等。
    >
    > OpenFeign的简化声明式API使得微服务之间的通信变得更加清晰和方便，它是构建微服务架构的重要工具之一，可帮助开发人员更轻松地构建和维护分布式系统。另外可以配合`Hystrix`实现降级和熔断。

24. 讲一下Dubbo框架是属于什么样的框架

    > Dubbo是一个开源的分布式服务框架，属于RPC（远程过程调用）框架的一种。它旨在简化分布式应用程序的开发，帮助构建高性能、松耦合、可伸缩的分布式系统。以下是关于Dubbo框架的一些重要特点和属性：
    >
    > 1. **RPC框架：** Dubbo是一个典型的RPC框架，它允许**不同节点上的应用程序之间像调用本地方法一样调用远程服务，隐藏了底层的网络通信细节**。
    > 2. **分布式服务治理：** **Dubbo提供了完善的分布式服务治理功能**，包括服务注册与发现、负载均衡、容错机制、动态路由等，帮助管理大规模微服务架构。
    > 3. **面向接口代理：** Dubbo的服务暴露和引用都是基于Java接口的，它使用Java的动态代理和反射机制来实现远程调用，使开发更加便捷。
    > 4. **高性能：** Dubbo在性能方面进行了优化，包括底层通信框架的选择（**支持多种通信协议如Dubbo协议、HTTP、RMI等**）、序列化机制的优化、多种负载均衡策略等。
    > 5. **异步通信：** Dubbo支持异步调用，允许客户端发起异步请求并通过回调方式获得结果，提高系统的吞吐量。
    > 6. **多语言支持：** Dubbo不仅支持Java，还支持多种编程语言，如Python、Ruby、JavaScript等。
    > 7. **开源社区：** Dubbo是一个活跃的开源项目，拥有大量的用户和开发者社区，提供了丰富的文档和生态系统。
    > 8. **可扩展性：** Dubbo的模块化设计使得它非常灵活，可以根据需求进行定制和扩展，例如，可以自定义扩展点和协议实现。
    >
    > 总的来说，Dubbo是一个用于构建分布式服务架构的**高性能、可扩展、全功能的框架**。它解决了分布式系统中的**通信、治理、性能**等一系列问题，适用于构建各种规模的分布式应用，特别是面向微服务的架构。由于其丰富的功能和社区支持，Dubbo在众多企业和项目中被广泛采用。

25. Dubbo和Http直接调用有什么区别吗

    > Dubbo和直接使用HTTP进行调用有一些重要区别，这些区别主要涉及**通信协议、性能、服务治理、接口定义**等方面。以下是Dubbo和HTTP直接调用的主要区别：
    >
    > 1. **通信协议：**
    >    - Dubbo使用自定义的二进制协议（Dubbo协议）进行通信，默认情况下，它使用高性能的Netty作为底层通信框架。这种自定义协议可以提供更高效的数据传输，减少了序列化和反序列化的开销。
    >    - 直接使用HTTP进行调用通常使用HTTP/HTTPS协议，这是一种文本协议，相对于Dubbo的二进制协议，它可能会有更多的开销。
    > 2. **性能：**
    >    - 由于Dubbo使用了二进制协议和性能优化的通信框架，通常来说，Dubbo具有更高的性能和更低的延迟。这使得它适用于对性能要求较高的分布式系统。
    >    - 直接使用HTTP的性能通常比Dubbo差一些，因为HTTP的文本协议会引入额外的序列化和反序列化开销。
    > 3. **服务治理：**
    >    - Dubbo提供了丰富的服务治理功能，包括服务注册与发现、负载均衡、容错机制、动态路由等，这些功能有助于构建可伸缩和高可用的分布式系统。
    >    - 直接使用HTTP通常需要自行处理服务治理的问题，例如，需要手动管理服务注册、实现负载均衡、处理服务降级等。
    > 4. **接口定义：**
    >    - 在Dubbo中，服务的接口定义通常采用Java接口的方式，并且支持面向接口的代理调用，这样开发人员可以更加便捷地使用服务。
    >    - 直接使用HTTP时，通常需要自行定义HTTP请求和响应的数据格式，并进行手动的HTTP请求发送和响应处理。
    > 5. **跨语言支持：**
    >    - Dubbo支持多种编程语言，使得不同语言的服务可以互相调用。
    >    - 直接使用HTTP也支持跨语言调用，但需要处理不同语言之间的数据格式转换和协议兼容性。
    >
    > 综上所述，Dubbo和直接使用HTTP都有各自的优势和适用场景。Dubbo适用于构建高性能、可伸缩、需要服务治理的分布式系统，而直接使用HTTP更简单，适用于一些小规模、无需高性能要求、跨语言调用的场景。选择哪种方式应该根据项目的具体需求和约束来决定。

26. 如果把Dubbo改为Open Feign调用，会不会有什么不一样的地方

    > 如果将Dubbo替换为OpenFeign来进行服务调用，会有一些不同之处，因为Dubbo和OpenFeign是两个不同的远程调用框架，它们具有不同的特性和用法。以下是将Dubbo替换为OpenFeign时可能需要考虑的一些不同之处：
    >
    > 1. **通信协议：**
    >    - Dubbo使用自定义的二进制协议进行通信，而OpenFeign通常使用HTTP协议。
    >    - 如果你将Dubbo替换为OpenFeign，需要确保服务提供者和消费者都能够支持HTTP通信。
    > 2. **服务治理：**
    >    - Dubbo提供了丰富的服务治理功能，包括服务注册与发现、负载均衡、容错机制等。OpenFeign通常不提供这些功能，需要额外的服务治理工具。
    >    - 如果你使用OpenFeign，可能需要考虑使用其他工具或服务注册中心来处理服务治理的问题。
    > 3. **接口定义：**
    >    - Dubbo的接口定义通常采用Java接口的方式，而OpenFeign使用标注注解的Java接口来定义HTTP请求。
    >    - 如果你将Dubbo替换为OpenFeign，需要重新定义接口，使用OpenFeign的注解来标识HTTP请求。
    > 4. **性能和延迟：**
    >    - 由于Dubbo采用了二进制协议和性能优化的通信框架，通常具有较高的性能和较低的延迟。
    >    - OpenFeign使用HTTP协议，通常会有一些额外的开销，可能会影响性能和延迟。
    > 5. **异步调用：**
    >    - Dubbo支持异步调用，可以提高系统吞吐量。OpenFeign也支持异步调用，但需要根据需要进行配置和使用。
    > 6. **跨语言支持：**
    >    - Dubbo支持多种编程语言，使得不同语言的服务可以互相调用。OpenFeign通常用于Java环境，不太适用于跨语言调用。
    >
    > 总之，将Dubbo替换为OpenFeign可能需要重新定义接口、处理服务治理、考虑性能和延迟等方面的问题。具体的差异和迁移过程将取决于项目的需求和现有架构。选择哪个框架应根据项目的具体情况和需求来决定。

27. 如何解决代码出现的报错问题？

    > 解决代码出现的报错问题通常需要经过以下一般性的步骤：
    >
    > 1. **理解报错信息：** 首先，仔细阅读报错信息，了解错误的类型、位置以及相关的上下文信息。报错信息通常包括错误消息、错误堆栈跟踪等。
    > 2. **查找问题原因：** 根据报错信息，尝试确定问题的根本原因。这可能涉及到变量值、方法调用、异常情况等方面的问题。
    > 3. **检查代码：** 仔细检查与报错相关的代码部分，确保代码的逻辑正确。可能需要查找变量赋值、条件语句、循环、方法调用等，以确认是否有错误。
    > 4. **使用调试工具：** 如果问题不明显或很难找到，可以使用调试工具来逐行或逐步调试代码，观察变量值和程序流程，以找出问题所在。
    > 5. **查阅文档和资源：** 如果你不确定如何解决问题，可以查阅相关的文档、教程、论坛或社区资源，寻求帮助和建议。
    > 6. **尝试解决方案：** 基于对问题的理解，尝试不同的解决方案。这可能包括更改代码、修复错误、优化算法等。
    > 7. **测试和验证：** 在应用任何解决方案之前，确保进行适当的测试和验证。运行代码，检查是否解决了问题，并确保没有引入新的问题。
    > 8. **版本控制：** 如果你使用版本控制工具（如Git），可以考虑创建分支来尝试不同的解决方案，以确保不会破坏主要代码。
    > 9. **循环迭代：** 如果问题没有被解决，需要反复进行上述步骤，直到问题被完全解决。
    > 10. **学习和改进：** 在解决问题的过程中，学习新的知识和技能是非常重要的。在将问题解决后，回顾问题的根本原因，并考虑如何改进代码，以避免类似问题的再次发生。
    >
    > 请注意，解决代码问题通常需要耐心和方法论。有时候，问题可能非常复杂，需要更多的时间和努力来解决。同时，积累解决问题的经验和技能是编程中的重要一部分。

28. 有没有了解过新技术？

29. Java方面一些新的框架有了解吗？

30. JDK现在更新到多少了，Java新特性说几个你了解的

    > 2023.9.24目前java的jdk已经更新到了21，在21中最重要的是支持了虚拟线程大大提高了吞吐量。
    >
    > 这里推荐在JavaGuide上查看：[java新特性](https://javaguide.cn/java/new-features/java8-common-new-features.html)

31. instanceof前面可以是null吗？

    > 在Java中，`instanceof`操作符前面的表达式可以是`null`。当表达式为`null`时，`instanceof`操作符会返回`false`。这是因为`null`不属于任何类的实例，因此不能匹配任何类型。
    >
    > 总之，`instanceof`操作符前面的表达式可以为`null`，并且在这种情况下，它会始终返回`false`。

32. 写代码有什么代码规范吗？说一下平时写代码会注意到了代码规范

    > 写代码时遵循代码规范是一种良好的编程实践，它有助于提高代码的可读性、可维护性和协作性。代码规范可以包括不同的方面，如命名约定、缩进风格、注释规范、代码结构等。以下是一些常见的代码规范和一些我平时会注意到的方面：
    >
    > 1. **命名约定：**
    >    - 使用有意义的变量名和函数名，以便其他人能够轻松理解代码的目的。
    >    - 使用驼峰命名法（camelCase）或下划线命名法（snake_case）来命名变量、函数、类等。
    >    - 避免使用过于简单或含糊不清的命名，如单个字母或缩写。
    > 2. **缩进和格式化：**
    >    - 使用一致的缩进风格，通常是四个空格或一个制表符。
    >    - 维护一致的代码格式，包括括号的位置、换行符的使用等。
    > 3. **注释规范：**
    >    - 使用注释来解释代码的目的、算法、特殊情况等。
    >    - 编写清晰的文档注释，包括类、方法和字段的说明。
    >    - 避免不必要的注释，代码本身应该尽可能自解释。
    > 4. **代码结构：**
    >    - 使用合适的包结构和模块化组织代码。
    >    - 将相关的功能放在独立的函数或方法中，保持函数的单一职责原则。
    >    - 避免过长的函数或方法，应该尽量简化和拆分复杂的逻辑。
    > 5. **错误处理：**
    >    - 使用异常处理来处理错误情况，不要忽略异常。
    >    - 避免空指针异常，使用空值检查或可空类型（如Java的Optional）来处理可能为空的情况。
    > 6. **版本控制：**
    >    - 使用版本控制工具（如Git）来管理代码，定期提交和推送更改。
    >    - 使用有意义的提交消息，解释为什么进行了更改。
    > 7. **性能优化：**
    >    - 编写高效的代码，避免不必要的循环和重复计算。
    >    - 使用合适的数据结构和算法来提高性能。
    > 8. **测试：**
    >    - 编写单元测试和集成测试来验证代码的正确性。
    >    - 在修改代码时确保测试仍然通过。
    > 9. **安全性：**
    >    - 防范常见的安全漏洞，如SQL注入、跨站脚本攻击等。
    >    - 遵循安全性最佳实践，保护敏感数据和系统。
    >
    > 这些只是代码规范的一些示例，实际的规范可能因编程语言、团队和项目而异。在团队开发中，一致地遵循代码规范是至关重要的，因为它有助于提高协作效率，减少错误，使代码更易于维护。平时写代码时，我会尽量遵循所使用编程语言的规范和项目团队的指导方针，并在必要时参考相应的编码规范文档。

33. 自动拆装箱，自动装箱的时候valueof与paresInt有什么区别？我们平时使用哪一个？

    > 自动装箱（Autoboxing）和自动拆箱（Unboxing）是Java中的特性，用于在基本数据类型和对应的包装类型之间进行转换。这两个特性使得编写代码更加方便，不再需要显式地进行类型转换。
    >
    > 在自动装箱和拆箱中，`valueOf`和`parseInt`是两个常用的方法，它们之间有一些区别：
    >
    > 1. valueOf方法：
    >    - `valueOf`是包装类型（例如`Integer`、`Double`等）的静态方法，用于将基本数据类型的值转换为包装类型的对象。
    >    - 这个方法通常用于自动装箱，例如将`int`转换为`Integer`，`double`转换为`Double`等。
    >
    > ```java
    > Integer num = Integer.valueOf(42); // 自动装箱
    > ```
    >
    > 2. parseInt方法：
    >
    > - `parseInt`是`Integer`类的静态方法，用于将字符串表示的整数解析为`int`基本数据类型。
    > - 这个方法通常用于将字符串转换为基本数据类型。
    >
    > ```java
    > int num = Integer.parseInt("42"); // 字符串转换为int
    > ```
    >
    > 总的来说，`valueOf`方法用于将**基本数据类型转换为包装类型对象**，而`parseInt`方法用于将字符串转换为`int`基本数据类型。它们的使用场景不同：
    >
    > - 如果你需要将基本数据类型的值包装为对应的包装类型对象，可以使用`valueOf`方法，这通常用于自动装箱。
    > - 如果你需要将字符串表示的整数解析为基本数据类型，可以使用`parseInt`方法。
    >
    > 在实际编程中，要根据具体的需求来选择使用哪种方法。通常情况下，自动装箱和拆箱会使代码更简洁，但在性能要求高的场景中，可能需要注意自动装箱和拆箱操作的开销。

34. 自动装箱与拆箱了解吗？原理是什么？

    > **什么是自动拆装箱？**
    >
    > - **装箱**：将基本类型用它们对应的引用类型包装起来；
    > - **拆箱**：将包装类型转换为基本数据类型；
    >
    > 从字节码中，我们发现装箱其实就是调用了 包装类的`valueOf()`方法，拆箱其实就是调用了 `xxxValue()`方法。
    >
    > 因此，
    >
    > - `Integer i = 10` 等价于 `Integer i = Integer.valueOf(10)`
    > - `int n = i` 等价于 `int n = i.intValue()`;